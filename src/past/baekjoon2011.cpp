/* 상근이와 선영이가 다른 사람들이 남매간의 대화를 듣는 것을 방지하기 위해서 대화를 서로 암호화 하기로 했다. 그래서 다음과 같은 대화를 했다.

상근: 그냥 간단히 암호화 하자. A를 1이라고 하고, B는 2로, 그리고 Z는 26으로 하는거야.
선영: 그럼 안돼. 만약, "BEAN"을 암호화하면 25114가 나오는데, 이걸 다시 글자로 바꾸는 방법은 여러 가지가 있어.
상근: 그렇네. 25114를 다시 영어로 바꾸면, "BEAAD", "YAAD", "YAN", "YKD", "BEKD", "BEAN" 총 6가지가 나오는데, BEAN이 맞는 단어라는건 쉽게 알수 있잖아?
선영: 예가 적절하지 않았네 ㅠㅠ 만약 내가 500자리 글자를 암호화 했다고 해봐. 그 때는 나올 수 있는 해석이 정말 많은데, 그걸 언제 다해봐?
상근: 얼마나 많은데?
선영: 구해보자!
어떤 암호가 주어졌을 때, 그 암호의 해석이 몇 가지가 나올 수 있는지 구하는 프로그램을 작성하시오.
나올 수 있는 해석의 가짓수를 구하시오. 정답이 매우 클 수 있으므로, 1000000으로 나눈 나머지를 출력한다.

암호가 잘못되어 암호를 해석할 수 없는 경우에는 0을 출력한다.
 */
#include <iostream>
#include <string>
using namespace std;
int main(){
	int MOD=1000000;
	int length;
	int code[5001];
	int dp[5000];
	string c;
	cin>>c;
	length=c.length();
	code[0]=0; //코드 앞에 0을 붙여줌
	for(int i=1; i<=length; i++)
		code[i]=c[i-1]-'0';
	if(length==1 && code[0]){ //코드가 0일 때 *예외처리
		cout<<0;
	}
	else{
		dp[0]=1; //dp 처음 값: 1로 설정(필요없는 값)
		for(int i=1; i<=length; i++){
			if(code[i]>0 && code[i]<10){ //i가 0이 아닌 한 자리수에 속하면
				dp[i]=dp[i-1]%MOD; //dp[i-1] 값 저장
			}
			if(code[i-1]*10+code[i]>9 && code[i-1]*10+code[i]<27){ //i 앞자리수를 포함해서 10에서 27 사이이면
				dp[i]=(dp[i-2]+dp[i])%MOD; //dp[i-2] 값을 더해줌
			}
		}
		cout<<dp[length]; //dp[length] 값이 정답
	}
	return 0;
}

//수행시간: O(n)
